--- a/include/nebula4x/core/simulation.h
+++ b/include/nebula4x/core/simulation.h
@@ -27,7 +27,7 @@
   ContentDB& content() { return content_; }
   const ContentDB& content() const { return content_; }
 
-  SimConfig cfg() const { return cfg_; }
+  const SimConfig& cfg() const { return cfg_; }
 
   GameState& state() { return state_; }
   const GameState& state() const { return state_; }
@@ -49,7 +49,13 @@
 
   // Gameplay actions
   bool issue_move_to_point(Id ship_id, Vec2 target_mkm);
-  bool issue_move_to_body(Id ship_id, Id body_id);
+  // Move to a body. If the body is in another system, the simulation will
+  // automatically enqueue TravelViaJump steps (using the jump network) and
+  // then complete the move in the destination system.
+  //
+  // When restrict_to_discovered is true, jump routing will only traverse
+  // systems discovered by the ship's faction.
+  bool issue_move_to_body(Id ship_id, Id body_id, bool restrict_to_discovered = false);
   bool issue_travel_via_jump(Id ship_id, Id jump_point_id);
   // Pathfind through the jump network and enqueue TravelViaJump steps to reach a target system.
   //
@@ -58,14 +64,30 @@
   //
   // Returns false if no route is known/available.
   bool issue_travel_to_system(Id ship_id, Id target_system_id, bool restrict_to_discovered = false);
-  bool issue_attack_ship(Id attacker_ship_id, Id target_ship_id);
+  // Attack a hostile ship.
+  //
+  // If the target is in another system, the simulation will auto-enqueue TravelViaJump steps
+  // to reach the target's current (if detected) or last-known (from contact memory) system,
+  // then pursue it once in-system.
+  //
+  // When restrict_to_discovered is true, jump routing will only traverse systems discovered
+  // by the attacker's faction.
+  bool issue_attack_ship(Id attacker_ship_id, Id target_ship_id, bool restrict_to_discovered = false);
 
   // Cargo / logistics (prototype).
   // Load/unload colony minerals into a ship's cargo hold.
   // - mineral == "" means "all minerals".
   // - tons <= 0 means "as much as possible".
-  bool issue_load_mineral(Id ship_id, Id colony_id, const std::string& mineral, double tons = 0.0);
-  bool issue_unload_mineral(Id ship_id, Id colony_id, const std::string& mineral, double tons = 0.0);
+  //
+  // If the colony is in another system, the simulation will automatically
+  // enqueue TravelViaJump steps before the load/unload order.
+  //
+  // When restrict_to_discovered is true, jump routing will only traverse
+  // systems discovered by the ship's faction.
+  bool issue_load_mineral(Id ship_id, Id colony_id, const std::string& mineral, double tons = 0.0,
+                          bool restrict_to_discovered = false);
+  bool issue_unload_mineral(Id ship_id, Id colony_id, const std::string& mineral, double tons = 0.0,
+                            bool restrict_to_discovered = false);
 
   bool enqueue_build(Id colony_id, const std::string& design_id);
 

--- a/src/core/simulation.cpp
+++ b/src/core/simulation.cpp
@@ -379,10 +379,20 @@
   return true;
 }
 
-bool Simulation::issue_move_to_body(Id ship_id, Id body_id) {
+bool Simulation::issue_move_to_body(Id ship_id, Id body_id, bool restrict_to_discovered) {
   auto* ship = find_ptr(state_.ships, ship_id);
   if (!ship) return false;
-  if (!find_ptr(state_.bodies, body_id)) return false;
+  const auto* body = find_ptr(state_.bodies, body_id);
+  if (!body) return false;
+
+  const Id target_system_id = body->system_id;
+  if (target_system_id == kInvalidId) return false;
+  if (!find_ptr(state_.systems, target_system_id)) return false;
+
+  // Route (if needed) so that when this order reaches the front of the queue,
+  // the ship will already be in the correct system.
+  if (!issue_travel_to_system(ship_id, target_system_id, restrict_to_discovered)) return false;
+
   auto& orders = state_.ship_orders[ship_id];
   orders.queue.push_back(MoveToBody{body_id});
   return true;
@@ -402,10 +412,35 @@
   if (!ship) return false;
   if (!find_ptr(state_.systems, target_system_id)) return false;
 
-  if (ship->system_id == target_system_id) return true; // no-op
+  // When queuing travel routes, treat the ship's "current" system as the system
+  // it will be in after executing any already-queued TravelViaJump orders.
+  // This makes Shift-queued travel routes behave intuitively.
+  auto predicted_system_after_queue = [&]() -> Id {
+    Id sys = ship->system_id;
+    auto it = state_.ship_orders.find(ship_id);
+    if (it == state_.ship_orders.end()) return sys;
+
+    for (const auto& ord : it->second.queue) {
+      if (!std::holds_alternative<TravelViaJump>(ord)) continue;
+      const Id jump_id = std::get<TravelViaJump>(ord).jump_point_id;
+      const auto* jp = find_ptr(state_.jump_points, jump_id);
+      if (!jp) continue;
+      if (jp->system_id != sys) continue;
+      if (jp->linked_jump_id == kInvalidId) continue;
+      const auto* dest = find_ptr(state_.jump_points, jp->linked_jump_id);
+      if (!dest) continue;
+      if (dest->system_id == kInvalidId) continue;
+      if (!find_ptr(state_.systems, dest->system_id)) continue;
+      sys = dest->system_id;
+    }
+    return sys;
+  };
+
+  const Id start = predicted_system_after_queue();
+  if (start == kInvalidId) return false;
+  if (start == target_system_id) return true; // no-op
 
   // Breadth-first search over the system graph, tracking the jump id used to traverse each edge.
-  const Id start = ship->system_id;
 
   auto allow_system = [&](Id sys_id) {
     if (!restrict_to_discovered) return true;
@@ -461,14 +496,12 @@
     cur = it_sys->second;
   }
   std::reverse(jumps.begin(), jumps.end());
-  if (jumps.empty()) return false;
-
   auto& orders = state_.ship_orders[ship_id];
   for (Id jid : jumps) orders.queue.push_back(TravelViaJump{jid});
   return true;
 }
 
-bool Simulation::issue_attack_ship(Id attacker_ship_id, Id target_ship_id) {
+bool Simulation::issue_attack_ship(Id attacker_ship_id, Id target_ship_id, bool restrict_to_discovered) {
   if (attacker_ship_id == target_ship_id) return false;
   auto* attacker = find_ptr(state_.ships, attacker_ship_id);
   if (!attacker) return false;
@@ -476,38 +509,44 @@
   if (!target) return false;
   if (target->faction_id == attacker->faction_id) return false;
 
-  // Simple sensor gating / intel-based targeting:
-  // - If the target is currently detected, record its true current position.
-  // - Otherwise, allow issuing an intercept if we have a recent contact snapshot.
-  //
-  // NOTE: Detection is currently in-system, and we don't have cross-system pathing.
-  // We still allow the order to be issued, but it will be dropped during ticking
-  // if the target is not in the same system.
+  // Sensor gating / intel-based targeting:
+  // - If the target is currently detected (by this faction, anywhere we have sensors), record its true position.
+  // - Otherwise, allow issuing an intercept if we have a contact snapshot (last-seen system + position).
   const bool detected = is_ship_detected_by_faction(attacker->faction_id, target_ship_id);
 
   AttackShip ord;
   ord.target_ship_id = target_ship_id;
+
+  Id target_system_id = kInvalidId;
 
   if (detected) {
     ord.has_last_known = true;
     ord.last_known_position_mkm = target->position_mkm;
+    target_system_id = target->system_id;
   } else {
     const auto* fac = find_ptr(state_.factions, attacker->faction_id);
     if (!fac) return false;
     const auto it = fac->ship_contacts.find(target_ship_id);
     if (it == fac->ship_contacts.end()) return false;
-    // Must be a contact in the same system as the attacker (no cross-system pathing yet).
-    if (it->second.system_id != attacker->system_id) return false;
     ord.has_last_known = true;
     ord.last_known_position_mkm = it->second.last_seen_position_mkm;
-  }
+    target_system_id = it->second.system_id;
+  }
+
+  if (target_system_id == kInvalidId) return false;
+  if (!find_ptr(state_.systems, target_system_id)) return false;
+
+  // Auto-route across systems so that when the attack order reaches the front of the queue,
+  // the ship will already be in the same system as the target (or last-known target system).
+  if (!issue_travel_to_system(attacker_ship_id, target_system_id, restrict_to_discovered)) return false;
 
   auto& orders = state_.ship_orders[attacker_ship_id];
   orders.queue.push_back(ord);
   return true;
 }
 
-bool Simulation::issue_load_mineral(Id ship_id, Id colony_id, const std::string& mineral, double tons) {
+bool Simulation::issue_load_mineral(Id ship_id, Id colony_id, const std::string& mineral, double tons,
+                                    bool restrict_to_discovered) {
   auto* ship = find_ptr(state_.ships, ship_id);
   if (!ship) return false;
   auto* colony = find_ptr(state_.colonies, colony_id);
@@ -515,15 +554,19 @@
   if (colony->faction_id != ship->faction_id) return false;
   const auto* body = find_ptr(state_.bodies, colony->body_id);
   if (!body) return false;
-  if (body->system_id != ship->system_id) return false;
+  if (body->system_id == kInvalidId) return false;
+  if (!find_ptr(state_.systems, body->system_id)) return false;
   if (tons < 0.0) return false;
+
+  if (!issue_travel_to_system(ship_id, body->system_id, restrict_to_discovered)) return false;
 
   auto& orders = state_.ship_orders[ship_id];
   orders.queue.push_back(LoadMineral{colony_id, mineral, tons});
   return true;
 }
 
-bool Simulation::issue_unload_mineral(Id ship_id, Id colony_id, const std::string& mineral, double tons) {
+bool Simulation::issue_unload_mineral(Id ship_id, Id colony_id, const std::string& mineral, double tons,
+                                      bool restrict_to_discovered) {
   auto* ship = find_ptr(state_.ships, ship_id);
   if (!ship) return false;
   auto* colony = find_ptr(state_.colonies, colony_id);
@@ -531,8 +574,11 @@
   if (colony->faction_id != ship->faction_id) return false;
   const auto* body = find_ptr(state_.bodies, colony->body_id);
   if (!body) return false;
-  if (body->system_id != ship->system_id) return false;
+  if (body->system_id == kInvalidId) return false;
+  if (!find_ptr(state_.systems, body->system_id)) return false;
   if (tons < 0.0) return false;
+
+  if (!issue_travel_to_system(ship_id, body->system_id, restrict_to_discovered)) return false;
 
   auto& orders = state_.ship_orders[ship_id];
   orders.queue.push_back(UnloadMineral{colony_id, mineral, tons});

--- a/src/ui/panels.cpp
+++ b/src/ui/panels.cpp
@@ -364,10 +364,18 @@
           ImGui::TextDisabled("Selected colony body missing.");
         } else if (sel_col->faction_id != sh->faction_id) {
           ImGui::TextDisabled("Selected colony is not friendly.");
-        } else if (sel_col_body->system_id != sh->system_id) {
-          ImGui::TextDisabled("Selected colony is in a different system.");
         } else {
           ImGui::Text("Colony: %s", sel_col->name.c_str());
+
+          if (sel_col_body->system_id != sh->system_id) {
+            std::string dest_label = "(unknown)";
+            const auto* dest_sys = find_ptr(s.systems, sel_col_body->system_id);
+            if (dest_sys && (!ui.fog_of_war || sim.is_system_discovered_by_faction(sh->faction_id, dest_sys->id))) {
+              dest_label = dest_sys->name;
+            }
+            ImGui::TextDisabled("Colony is in a different system %s. Order will auto-route via jump points.",
+                                dest_label.c_str());
+          }
 
           // Build a stable mineral list (union of colony minerals + ship cargo).
           std::vector<std::string> minerals;
@@ -400,11 +408,15 @@
           const std::string mineral_id = (mineral_idx == 0) ? std::string() : minerals[mineral_idx - 1];
 
           if (ImGui::Button("Load##cargo")) {
-            sim.issue_load_mineral(selected_ship, selected_colony, mineral_id, transfer_tons);
+            if (!sim.issue_load_mineral(selected_ship, selected_colony, mineral_id, transfer_tons, ui.fog_of_war)) {
+              nebula4x::log::warn("Couldn't queue load order (no known route?).");
+            }
           }
           ImGui::SameLine();
           if (ImGui::Button("Unload##cargo")) {
-            sim.issue_unload_mineral(selected_ship, selected_colony, mineral_id, transfer_tons);
+            if (!sim.issue_unload_mineral(selected_ship, selected_colony, mineral_id, transfer_tons, ui.fog_of_war)) {
+              nebula4x::log::warn("Couldn't queue unload order (no known route?).");
+            }
           }
         }
 
@@ -420,7 +432,9 @@
             for (Id bid : sys2->bodies) {
               const auto* b = find_ptr(s.bodies, bid);
               if (b && b->name == "Earth") {
-                sim.issue_move_to_body(selected_ship, b->id);
+                if (!sim.issue_move_to_body(selected_ship, b->id, ui.fog_of_war)) {
+                  nebula4x::log::warn("Couldn't issue move-to-body order.");
+                }
                 break;
               }
             }
@@ -480,7 +494,7 @@
               if (range > 0.0) {
                 ImGui::SameLine();
                 if (ImGui::SmallButton(("Attack##" + std::to_string(hid)).c_str())) {
-                  sim.issue_attack_ship(sh->id, hid);
+                  sim.issue_attack_ship(sh->id, hid, ui.fog_of_war);
                 }
               }
             }
@@ -1080,7 +1094,7 @@
                   const char* btn = detected_now ? "Attack" : "Intercept";
                   if (ImGui::SmallButton((std::string(btn) + "##" + std::to_string(r.c.ship_id)).c_str())) {
                     // If not currently detected, this will issue an intercept based on the stored contact snapshot.
-                    sim.issue_attack_ship(selected_ship, r.c.ship_id);
+                    sim.issue_attack_ship(selected_ship, r.c.ship_id, ui.fog_of_war);
                   }
                 }
               }

--- a/tests/test_auto_routing.cpp
+++ b/tests/test_auto_routing.cpp
@@ -0,0 +1,259 @@
+#include <iostream>
+#include <string>
+#include <variant>
+#include <algorithm>
+
+#include "nebula4x/core/simulation.h"
+
+#define N4X_ASSERT(expr)                                                                            \
+  do {                                                                                              \
+    if (!(expr)) {                                                                                  \
+      std::cerr << "ASSERT failed: " #expr " (" << __FILE__ << ":" << __LINE__ << ")\n";           \
+      return 1;                                                                                     \
+    }                                                                                               \
+  } while (0)
+
+namespace {
+
+nebula4x::Id find_ship_id(const nebula4x::GameState& st, const std::string& name) {
+  for (const auto& [sid, sh] : st.ships) {
+    if (sh.name == name) return sid;
+  }
+  return nebula4x::kInvalidId;
+}
+
+nebula4x::Id find_system_id(const nebula4x::GameState& st, const std::string& name) {
+  for (const auto& [sid, sys] : st.systems) {
+    if (sys.name == name) return sid;
+  }
+  return nebula4x::kInvalidId;
+}
+
+nebula4x::Id find_body_id(const nebula4x::GameState& st, const std::string& name) {
+  for (const auto& [bid, b] : st.bodies) {
+    if (b.name == name) return bid;
+  }
+  return nebula4x::kInvalidId;
+}
+
+nebula4x::Id find_colony_id(const nebula4x::GameState& st, const std::string& name) {
+  for (const auto& [cid, c] : st.colonies) {
+    if (c.name == name) return cid;
+  }
+  return nebula4x::kInvalidId;
+}
+
+} // namespace
+
+int test_auto_routing() {
+  nebula4x::ContentDB content;
+
+  auto add_min_design = [&](const std::string& id) {
+    nebula4x::ShipDesign d;
+    d.id = id;
+    d.name = id;
+    d.speed_km_s = 0.0;
+    d.max_hp = 10.0;
+    content.designs[id] = d;
+  };
+
+  // Ensure default scenario ships have designs (keeps stats deterministic).
+  add_min_design("freighter_alpha");
+  add_min_design("surveyor_beta");
+  add_min_design("escort_gamma");
+  add_min_design("pirate_raider");
+
+  nebula4x::Simulation sim(std::move(content), nebula4x::SimConfig{});
+
+  const auto ship_id = find_ship_id(sim.state(), "Freighter Alpha");
+  N4X_ASSERT(ship_id != nebula4x::kInvalidId);
+
+  const auto sol_sys = find_system_id(sim.state(), "Sol");
+  const auto cen_sys = find_system_id(sim.state(), "Alpha Centauri");
+  const auto bar_sys = find_system_id(sim.state(), "Barnard's Star");
+  N4X_ASSERT(sol_sys != nebula4x::kInvalidId);
+  N4X_ASSERT(cen_sys != nebula4x::kInvalidId);
+  N4X_ASSERT(bar_sys != nebula4x::kInvalidId);
+
+  const auto cen_prime = find_body_id(sim.state(), "Centauri Prime");
+  const auto barnard_b = find_body_id(sim.state(), "Barnard b");
+  N4X_ASSERT(cen_prime != nebula4x::kInvalidId);
+  N4X_ASSERT(barnard_b != nebula4x::kInvalidId);
+
+  // --- move-to-body auto-routes across systems ---
+  {
+    N4X_ASSERT(sim.clear_orders(ship_id));
+    N4X_ASSERT(sim.issue_move_to_body(ship_id, cen_prime));
+
+    const auto& q = sim.state().ship_orders.at(ship_id).queue;
+    N4X_ASSERT(q.size() == 2);
+
+    N4X_ASSERT(std::holds_alternative<nebula4x::TravelViaJump>(q[0]));
+    const auto jid = std::get<nebula4x::TravelViaJump>(q[0]).jump_point_id;
+    const auto* jp = nebula4x::find_ptr(sim.state().jump_points, jid);
+    N4X_ASSERT(jp);
+    N4X_ASSERT(jp->system_id == sol_sys);
+
+    const auto* dest = nebula4x::find_ptr(sim.state().jump_points, jp->linked_jump_id);
+    N4X_ASSERT(dest);
+    N4X_ASSERT(dest->system_id == cen_sys);
+
+    N4X_ASSERT(std::holds_alternative<nebula4x::MoveToBody>(q[1]));
+    N4X_ASSERT(std::get<nebula4x::MoveToBody>(q[1]).body_id == cen_prime);
+  }
+
+
+  // --- attack auto-routes across systems (via last-known contact system) ---
+  {
+    const auto escort_id = find_ship_id(sim.state(), "Escort Gamma");
+    N4X_ASSERT(escort_id != nebula4x::kInvalidId);
+
+    const auto raider_id = find_ship_id(sim.state(), "Raider I");
+    N4X_ASSERT(raider_id != nebula4x::kInvalidId);
+
+    const auto terrans = sim.state().ships.at(escort_id).faction_id;
+
+    // Having a contact in a system implies the faction has discovered it.
+    {
+      auto& ds = sim.state().factions.at(terrans).discovered_systems;
+      if (std::find(ds.begin(), ds.end(), cen_sys) == ds.end()) ds.push_back(cen_sys);
+    }
+
+    // Seed a contact snapshot for the raider in Centauri so the attack order can be issued even
+    // without current detection.
+    {
+      const auto& raider = sim.state().ships.at(raider_id);
+      nebula4x::Contact c;
+      c.ship_id = raider_id;
+      c.system_id = cen_sys;
+      c.last_seen_day = static_cast<int>(sim.state().date.days_since_epoch());
+      c.last_seen_position_mkm = raider.position_mkm;
+      c.last_seen_name = raider.name;
+      c.last_seen_design_id = raider.design_id;
+      c.last_seen_faction_id = raider.faction_id;
+      sim.state().factions[terrans].ship_contacts[raider_id] = c;
+    }
+
+    N4X_ASSERT(sim.clear_orders(escort_id));
+    N4X_ASSERT(sim.issue_attack_ship(escort_id, raider_id, true));
+
+    const auto& q = sim.state().ship_orders.at(escort_id).queue;
+    N4X_ASSERT(q.size() == 2);
+    N4X_ASSERT(std::holds_alternative<nebula4x::TravelViaJump>(q[0]));
+    N4X_ASSERT(std::holds_alternative<nebula4x::AttackShip>(q[1]));
+
+    const auto j = std::get<nebula4x::TravelViaJump>(q[0]).jump_point_id;
+    const auto* jp = nebula4x::find_ptr(sim.state().jump_points, j);
+    N4X_ASSERT(jp);
+    N4X_ASSERT(jp->system_id == sol_sys);
+    const auto* dest = nebula4x::find_ptr(sim.state().jump_points, jp->linked_jump_id);
+    N4X_ASSERT(dest);
+    N4X_ASSERT(dest->system_id == cen_sys);
+  }
+
+  // --- queued travel routes start from the end-of-queue system ---
+  {
+    N4X_ASSERT(sim.clear_orders(ship_id));
+    N4X_ASSERT(sim.issue_travel_to_system(ship_id, cen_sys));
+    N4X_ASSERT(sim.issue_travel_to_system(ship_id, bar_sys));
+
+    const auto& q = sim.state().ship_orders.at(ship_id).queue;
+    N4X_ASSERT(q.size() == 2);
+
+    N4X_ASSERT(std::holds_alternative<nebula4x::TravelViaJump>(q[0]));
+    N4X_ASSERT(std::holds_alternative<nebula4x::TravelViaJump>(q[1]));
+
+    const auto j1 = std::get<nebula4x::TravelViaJump>(q[0]).jump_point_id;
+    const auto* jp1 = nebula4x::find_ptr(sim.state().jump_points, j1);
+    N4X_ASSERT(jp1);
+    N4X_ASSERT(jp1->system_id == sol_sys);
+    const auto* d1 = nebula4x::find_ptr(sim.state().jump_points, jp1->linked_jump_id);
+    N4X_ASSERT(d1);
+    N4X_ASSERT(d1->system_id == cen_sys);
+
+    const auto j2 = std::get<nebula4x::TravelViaJump>(q[1]).jump_point_id;
+    const auto* jp2 = nebula4x::find_ptr(sim.state().jump_points, j2);
+    N4X_ASSERT(jp2);
+    N4X_ASSERT(jp2->system_id == cen_sys);
+    const auto* d2 = nebula4x::find_ptr(sim.state().jump_points, jp2->linked_jump_id);
+    N4X_ASSERT(d2);
+    N4X_ASSERT(d2->system_id == bar_sys);
+  }
+
+  // --- cargo orders can auto-route across systems ---
+  {
+    const auto earth = find_colony_id(sim.state(), "Earth");
+    N4X_ASSERT(earth != nebula4x::kInvalidId);
+
+    // Use the Earth colony's owning faction (avoids hard-coding faction names).
+    const auto terrans = sim.state().colonies.at(earth).faction_id;
+    N4X_ASSERT(terrans != nebula4x::kInvalidId);
+    N4X_ASSERT(nebula4x::find_ptr(sim.state().factions, terrans));
+
+    nebula4x::Colony outpost;
+    outpost.id = nebula4x::allocate_id(sim.state());
+    outpost.name = "Centauri Outpost";
+    outpost.faction_id = terrans;
+    outpost.body_id = cen_prime;
+    outpost.population_millions = 1.0;
+    outpost.minerals["Duranium"] = 0.0;
+
+    sim.state().colonies[outpost.id] = outpost;
+
+    N4X_ASSERT(sim.clear_orders(ship_id));
+    N4X_ASSERT(sim.issue_load_mineral(ship_id, earth, "Duranium", 10.0));
+    N4X_ASSERT(sim.issue_unload_mineral(ship_id, outpost.id, "Duranium", 10.0));
+
+    const auto& q = sim.state().ship_orders.at(ship_id).queue;
+    N4X_ASSERT(q.size() == 3);
+
+    N4X_ASSERT(std::holds_alternative<nebula4x::LoadMineral>(q[0]));
+    N4X_ASSERT(std::holds_alternative<nebula4x::TravelViaJump>(q[1]));
+    N4X_ASSERT(std::holds_alternative<nebula4x::UnloadMineral>(q[2]));
+
+    const auto jid = std::get<nebula4x::TravelViaJump>(q[1]).jump_point_id;
+    const auto* jp = nebula4x::find_ptr(sim.state().jump_points, jid);
+    N4X_ASSERT(jp);
+    N4X_ASSERT(jp->system_id == sol_sys);
+    const auto* dest = nebula4x::find_ptr(sim.state().jump_points, jp->linked_jump_id);
+    N4X_ASSERT(dest);
+    N4X_ASSERT(dest->system_id == cen_sys);
+
+    N4X_ASSERT(std::get<nebula4x::UnloadMineral>(q[2]).colony_id == outpost.id);
+  }
+
+  // --- same-system orders appended after travel will auto-route back ---
+  {
+    const auto earth = find_colony_id(sim.state(), "Earth");
+    N4X_ASSERT(earth != nebula4x::kInvalidId);
+
+    N4X_ASSERT(sim.clear_orders(ship_id));
+    N4X_ASSERT(sim.issue_travel_to_system(ship_id, cen_sys));
+    N4X_ASSERT(sim.issue_load_mineral(ship_id, earth, "Duranium", 1.0));
+
+    const auto& q = sim.state().ship_orders.at(ship_id).queue;
+    N4X_ASSERT(q.size() == 3);
+
+    N4X_ASSERT(std::holds_alternative<nebula4x::TravelViaJump>(q[0]));
+    N4X_ASSERT(std::holds_alternative<nebula4x::TravelViaJump>(q[1]));
+    N4X_ASSERT(std::holds_alternative<nebula4x::LoadMineral>(q[2]));
+
+    const auto j1 = std::get<nebula4x::TravelViaJump>(q[0]).jump_point_id;
+    const auto* jp1 = nebula4x::find_ptr(sim.state().jump_points, j1);
+    N4X_ASSERT(jp1);
+    N4X_ASSERT(jp1->system_id == sol_sys);
+    const auto* d1 = nebula4x::find_ptr(sim.state().jump_points, jp1->linked_jump_id);
+    N4X_ASSERT(d1);
+    N4X_ASSERT(d1->system_id == cen_sys);
+
+    const auto j2 = std::get<nebula4x::TravelViaJump>(q[1]).jump_point_id;
+    const auto* jp2 = nebula4x::find_ptr(sim.state().jump_points, j2);
+    N4X_ASSERT(jp2);
+    N4X_ASSERT(jp2->system_id == cen_sys);
+    const auto* d2 = nebula4x::find_ptr(sim.state().jump_points, jp2->linked_jump_id);
+    N4X_ASSERT(d2);
+    N4X_ASSERT(d2->system_id == sol_sys);
+  }
+
+  return 0;
+}

--- a/tests/test_main.cpp
+++ b/tests/test_main.cpp
@@ -3,12 +3,14 @@
 int test_date();
 int test_simulation();
 int test_serialization();
+int test_auto_routing();
 
 int main() {
   int fails = 0;
   fails += test_date();
   fails += test_simulation();
   fails += test_serialization();
+  fails += test_auto_routing();
 
   if (fails == 0) {
     std::cout << "All tests passed\n";

--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -138,6 +138,7 @@
     tests/test_date.cpp
     tests/test_simulation.cpp
     tests/test_serialization.cpp
+    tests/test_auto_routing.cpp
   )
   target_link_libraries(nebula4x_tests PRIVATE nebula4x::core)
   nebula4x_set_project_warnings(nebula4x_tests ${NEBULA4X_WARNINGS_AS_ERRORS})

--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -0,0 +1,29 @@
+name: CI
+
+on:
+  push:
+    branches: [ "main" ]
+  pull_request:
+    branches: [ "main" ]
+
+jobs:
+  core:
+    name: Core build + tests (${{ matrix.os }})
+    runs-on: ${{ matrix.os }}
+    strategy:
+      fail-fast: false
+      matrix:
+        os: [ubuntu-latest, windows-latest, macos-latest]
+
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+
+      - name: Configure (core preset)
+        run: cmake --preset core
+
+      - name: Build (Release)
+        run: cmake --build --preset core --config Release
+
+      - name: Test
+        run: ctest --preset core -C Release

--- a/.gitignore
+++ b/.gitignore
@@ -0,0 +1,28 @@
+# Build outputs
+/build/
+/out/
+/cmake-build-*/
+CMakeFiles/
+CMakeCache.txt
+cmake_install.cmake
+compile_commands.json
+Makefile
+
+# IDEs
+.vscode/
+.idea/
+*.user
+*.vcxproj*
+*.sln
+*.opensdf
+*.sdf
+*.suo
+*.ncb
+
+# OS junk
+.DS_Store
+Thumbs.db
+
+# Logs / saves (if you generate them locally)
+*.log
+*.sav

--- a/.editorconfig
+++ b/.editorconfig
@@ -0,0 +1,15 @@
+root = true
+
+[*]
+charset = utf-8
+end_of_line = lf
+insert_final_newline = true
+indent_style = space
+indent_size = 2
+trim_trailing_whitespace = true
+
+[*.{cpp,h,hpp,c,cc}]
+indent_size = 2
+
+[*.md]
+trim_trailing_whitespace = false

--- a/.clang-format
+++ b/.clang-format
@@ -0,0 +1,6 @@
+BasedOnStyle: LLVM
+IndentWidth: 2
+ColumnLimit: 100
+AllowShortFunctionsOnASingleLine: Empty
+DerivePointerAlignment: false
+PointerAlignment: Left
